### 1. 什么是所有权
在Rust中每个值都属于一个变量，那么这个变量就是这个值的所有者。值在任意一个时刻有且仅有一个所有者。当所有者离开作用域时，这个值会被抛弃。

```rust
{
	let s = "hello";  //s 是 “hello”这个变量的所有者，此时还在作用域内所以s有效
} //作用域已经结束，所以后面s的值将不会再有效

```

### 2.所有权的转移

```rust
{
	let s1 = String::from("hello"); //此时s1是"hello"这个字符串的所有者
	let s2 = s1; //这里发生字符串所有权的转移从s1转移到s2
	println!("{},world",s1); //这时会报错因为s1已经不再是字符串的所有者
}
```

```rust
{
let x1 = 2;
let x2 = x1;
println!("x1 is {}",x1); //那么现在会报错吗？答案是不会报错
}
```

现在就会出现一个疑问：为什么`s1`会报错而`x1`不会报错呢？
```rust
{
	let s1 = String::from("hello"); 
	let s2 = s1; //假设这里是相同于x1的赋值操作
	println!("{},world",s1); 
} //好了现在代码离开作用域要释放内存了，由于s1和s2指向的都是同一块内存，内存释放了两次，所以发生内存双重释放的问题。

```

现在又会有一个问题了为什么`x1`和`x2`不会发生内存释放两次呢？

`s1`和`s2`是`String`类型，数据是存放在堆中的而其栈中存放的是指向其堆的地址，
`x1`和`x2`是`u8`类型是存放再栈中。储存在堆上的数据类型的数据大小在编译期间是未知的，考虑到性能问题比如一个很长的字符串进行复制那么就要为变量重新分配内存并复制其数据代价比较大，现在我们只是把指向内存的地址移动到一个新的变量里代价是不是小很多。
对于`x1`和`x2`这种存储在栈上的简单数据类型进行复制代价就小很多了，因为在编译时就知道它们的大小，而且通常非常小。


如果就是想`s1`和`s2`都能使用有没有解决方案呢？当然有:克隆。
```rust
{
	let s1 = String::from("hello"); 
	let s2 = s1.clone(); // 创建了一个完全新的String，内容是s1的复制。 
	println!("s1 = {}, s2 = {}", s1, s2); // 这是完全OK的。
}

```
